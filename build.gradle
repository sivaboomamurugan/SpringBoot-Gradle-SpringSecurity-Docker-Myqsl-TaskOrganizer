buildscript {
	ext {
		springBootVersion = '2.1.2.RELEASE'
	}
	repositories {
		maven {
			url "https://plugins.gradle.org/m2/"
		}
		mavenCentral()
	}
	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
		classpath('gradle.plugin.com.palantir.gradle.docker:gradle-docker:0.13.0')
	}
}

apply plugin: 'java'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'
apply plugin: 'idea'
apply plugin: 'com.palantir.docker'
apply plugin: "jacoco"

group = 'pjt'
version = '1.0'
sourceCompatibility = '1.8'

bootJar {
	baseName = 'task-organizer'
	version =  '1.0'
}

repositories {
	mavenCentral()
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-actuator'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-security'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	runtimeOnly 'mysql:mysql-connector-java'
	implementation 'org.springframework.boot:spring-boot-starter-test'
	implementation 'org.springframework.security:spring-security-test'

	testCompile 'junit:junit:4.12'
	testCompile 'org.mockito:mockito-core:2.7.22'
}

springBoot {
	mainClassName = "com.siva.taskorganizer.TaskorganizerApplication"
}

def javaVersion = JavaVersion.VERSION_1_8;
sourceCompatibility = javaVersion;
targetCompatibility = javaVersion;
task enforceVersion << {
	def foundVersion = JavaVersion.current();
	if (foundVersion != javaVersion)
		throw new IllegalStateException("Wrong Java version; required is "
				+ javaVersion + ", but found " + foundVersion);
}

compileJava.dependsOn(enforceVersion);

/*task bootDebug(type: org.springframework.boot.gradle.run.BootRunTask, dependsOn: 'build') {
	systemProperties = System.getProperties()
	//systemProperty('spring.profiles.active', 'qa')
	group = 'Application'
	description 'Runs this project as a JVM application in debug mode on port 6005'
	jvmArgs = ["-Xdebug", "-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=6005"]
	doFirst() {
		main = project.mainClassName
		classpath = sourceSets.main.runtimeClasspath
	}
	if(project.hasProperty('args')){
		args project.args.split('\\s+')
	}
}*/

task wrapper(type: Wrapper) {
	gradleVersion = '4.10.2'
}

task unpack(type: Copy) {
	dependsOn bootJar
	from(zipTree(tasks.bootJar.outputs.files.singleFile))
	into("build/dependency")
}
docker {
	name "${project.group}/${bootJar.baseName}"
	copySpec.from(tasks.unpack.outputs).into("dependency")
	buildArgs(['DEPENDENCY': "dependency"])
}


ext {
	limits = [
			'instruction': 0,
			'branch'     : 0,
			'line'       : 0,
			'complexity' : 0,
			'method'     : 0,
			'class'      : 0 //TODO - 100%
	]
}

check.dependsOn jacocoTestReport

jacocoTestReport {
	reports {
		//XML required by coveralls and for the below coverage checks
		xml.enabled true
	}

	doLast {
		def report = file("${jacoco.reportsDir}/test/jacocoTestReport.xml")
		logger.lifecycle("Checking coverage results: ${report}")

		def parser = new XmlParser()
		parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
		parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
		def results = parser.parse(report)

		def percentage = {
			def covered = it.'@covered' as Double
			def missed = it.'@missed' as Double
			((covered / (covered + missed)) * 100).round(2)
		}

		def counters = results.counter
		def metrics = [:]
		metrics << [
				'instruction': percentage(counters.find { it.'@type'.equals('INSTRUCTION') }),
				'branch'     : percentage(counters.find { it.'@type'.equals('BRANCH') }),
				'line'       : percentage(counters.find { it.'@type'.equals('LINE') }),
				'complexity' : percentage(counters.find { it.'@type'.equals('COMPLEXITY') }),
				'method'     : percentage(counters.find { it.'@type'.equals('METHOD') }),
				'class'      : percentage(counters.find { it.'@type'.equals('CLASS') })
		]


		def failures = []
		metrics.each {
			def limit = limits[it.key]
			if (it.value < limit) {
				failures.add("- ${it.key} coverage rate is: ${it.value}%, minimum is ${limit}%")
			}
		}

		if (failures) {
			logger.quiet("------------------ Code Coverage Failed -----------------------")
			failures.each {
				logger.quiet(it)
			}
			logger.quiet("---------------------------------------------------------------")
			throw new GradleException("Code coverage failed")
		} else{
			logger.quiet("Passed Code Coverage Checks")
		}
	}
}


test {
	testLogging {
		showStandardStreams = true
		exceptionFormat = 'full'
	}
	jacoco {
		destinationFile = file("${project.buildDir}/jacoco/UT/jacocoUT.exec")
	}
}


